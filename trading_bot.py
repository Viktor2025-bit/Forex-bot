import logging
import json
import time
import os
import sys
from datetime import datetime
import pandas as pd
import numpy as np

try:
    import yfinance as yf
except ImportError:
    yf = None

# Corrected Imports
# from config import Config  <-- REMOVED
from strategies.risk_manager import RiskManager
from strategies.order_executor import OrderExecutor, OrderSide, OrderStatus
from utils.retrainer import RetrainingManager

# Suppress WarningsExecutor, OrderStatus
from strategy_engine import AIStrategy, EnsembleStrategy, TradeAction
from utils.data_loader import fetch_historical_data, save_data, fetch_data_mt5
from utils.monitoring import BotMonitor, TradeRecord
from models.lstm_model import TradingLSTM
from ai_model import ForexModel
from utils.preprocessing import DataPreprocessor
from feature_engine import FeatureEngine

# Setup basic logging first (monitor will take over)
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class TradingBot:
    def __init__(self, config: dict):
        self.config = config
        
        # Initialize Monitor first to capture startup events
        alert_config = config.get('alerts', {})
        self.monitor = BotMonitor(
            log_dir="logs",
            enable_email=alert_config.get('email_enabled', False)
        )
        self.monitor.alerts.smtp_server = alert_config.get('smtp_server', "")
        self.monitor.alerts.smtp_port = alert_config.get('smtp_port', 587)
        self.monitor.alerts.smtp_user = alert_config.get('smtp_user', "")
        self.monitor.alerts.smtp_password = alert_config.get('smtp_password', "")
        self.monitor.alerts.alert_email = alert_config.get('alert_email', "")
        
        self.monitor.logger.info("Initializing Trading Bot...")
        
        # Market settings
        self.market_type = config.get('bot', {}).get('market_type', 'forex')
        self.symbols = config.get('markets', {}).get(self.market_type, {}).get('symbols', [])
        
        # Components
        from strategies.risk_manager import RiskParameters
        risk_config = config.get('risk', {})
        risk_params = RiskParameters(
            max_position_size_pct=risk_config.get('max_position_size_pct', 0.1),
            max_daily_loss_pct=risk_config.get('max_daily_loss_pct', 0.02),
            stop_loss_pct=risk_config.get('stop_loss_pct', 0.02),
            take_profit_pct=risk_config.get('take_profit_pct', 0.04),
            max_open_positions=risk_config.get('max_open_positions', 3),
            min_confidence=risk_config.get('min_confidence', 0.55)
        )
        self.risk_manager = RiskManager(risk_params)
        
        # Order Executor
        if config.get('bot', {}).get('paper_trading', True):
            from strategies.order_executor import PaperTradingExecutor # Import here to avoid circular dependency if OrderExecutor is also in this file
            self.executor = PaperTradingExecutor(initial_capital=config.get('bot', {}).get('initial_capital', 10000))
        elif config.get('brokers', {}).get('deriv', {}).get('enabled'):
            from strategies.deriv_executor import DerivExecutorSync
            deriv_cfg = config.get('brokers', {}).get('deriv', {})
            self.executor = DerivExecutorSync(api_token=deriv_cfg['api_token'], server=deriv_cfg.get('server', 'demo'))
            self.monitor.logger.info("Using Deriv Executor")
        else:
            from strategies.order_executor import MT5Executor
            mt5_cfg = config.get('brokers', {}).get('mt5', {})
            self.executor = MT5Executor(login=int(mt5_cfg['login']), password=mt5_cfg['password'], server=mt5_cfg['server']) 
        
        # Model and Preprocessor Setup for Ensemble

        
        # Model and Preprocessor Setup for Ensemble
        # Note: LSTM input_size must match the number of features generated by FeatureEngine (currently 57)
        self.preprocessors = {
            'lstm': FeatureEngine(),
            'xgboost': FeatureEngine()
        }
        
        # Load models for EACH symbol
        self.models = {}
        for symbol in self.symbols:
            self.monitor.logger.info(f"Loading models for {symbol}...")
            self.models[symbol] = {
                'lstm': self._load_model('lstm', symbol),
                'xgboost': self._load_model('xgboost', symbol)
            }
            
        self.seq_length = config.get('bot', {}).get('seq_length', 30)
        self.trading_interval = config.get('bot', {}).get('trading_interval_seconds', 60)
        
        # Strategy
        strategy_name = config.get('model', {}).get('strategy', 'ai')
        if strategy_name == 'ensemble':
            self.strategy = EnsembleStrategy(config)
            self.monitor.logger.info("Using Ensemble Strategy")
        else:
            self.strategy = AIStrategy(config)
            self.monitor.logger.info("Using AI Strategy")


        # State
        self.positions = {symbol: None for symbol in self.symbols}
        self.entry_prices = {symbol: None for symbol in self.symbols}
        self.last_prediction = {}
        self.daily_pnl = 0.0
        self.last_trade_day = datetime.now().date()
        self.trading_halted = False
        
        # Initialize Retrainer
        self.retrainer = RetrainingManager(accuracy_threshold=0.55, min_trades=20)
        
        # Load Models
        self.models = {}
        self.monitor.logger.info(f"Bot initialized for {self.symbols} ({'Paper' if self.executor.paper_trading else 'LIVE'} trading)")

    def _load_model(self, model_type: str, symbol: str):
        model_config = self.config.get('model', {})
        
        if model_type == 'xgboost':
            xg_params = model_config.get('xgboost', {})
            # Dynamic path: models/{symbol}_xgboost.json
            actual_path = f"models/{symbol}_xgboost.json"
            
            # Exclude model_path from xg_params
            training_params = {k: v for k, v in xg_params.items() if k != 'model_path'}
            
            model = ForexModel(model_path=actual_path, **training_params)
            if os.path.exists(actual_path):
                model.load_model()
                self.monitor.logger.info(f"[{symbol}] XGBoost Model loaded from {actual_path}")
            else:
                self.monitor.logger.warning(f"[{symbol}] XGBoost model not found at {actual_path}. Using untrained model/fallback.")
            return model

        elif model_type == 'lstm':
            lstm_params = model_config.get('lstm', {})
            # Dynamic path: models/{symbol}_lstm.pth
            model_path = f"models/{symbol}_lstm.pth"
            
            # Input size is 57 (from FeatureEngine with new indicators)
            model = TradingLSTM(input_size=57, hidden_size=lstm_params.get('hidden_size', 64), num_layers=lstm_params.get('num_layers', 2))
            if os.path.exists(model_path):
                import torch
                try:
                    # Note: Loading weights will fail if the model was trained with a different input_size
                    model.load_state_dict(torch.load(model_path))
                    model.eval()
                    self.monitor.logger.info(f"[{symbol}] LSTM Model loaded from {model_path}")
                except Exception as e:
                    self.monitor.logger.error(f"[{symbol}] Failed to load LSTM weights. Using untrained. Error: {e}")
            else:
                self.monitor.logger.warning(f"[{symbol}] LSTM model not found at {model_path}. Using untrained model.")
            return model
        
        return None

    def prepare_features(self, df: pd.DataFrame, model_type: str):
        preprocessor = self.preprocessors.get(model_type)
        if not preprocessor:
            return None

        try:
            if model_type == 'xgboost':
                df_features = preprocessor.generate_features(df)
                ignore_cols = ['Target', 'Future_Return', 'Date', 'index', 'Open', 'High', 'Low', 'Close', 'Volume']
                feature_cols = [c for c in df_features.columns if c not in ignore_cols]
                return df_features[feature_cols] if not df_features.empty else None
            
            elif model_type == 'lstm':
                df_features = preprocessor.generate_features(df)
                
                # Normalize numeric columns (same as training)
                from sklearn.preprocessing import StandardScaler
                feature_columns = [col for col in df_features.columns if df_features[col].dtype in ['float64', 'int64', 'float32', 'int32']]
                feature_columns = [col for col in feature_columns if col not in ['Date', 'Datetime']]
                
                scaler = StandardScaler()
                data_scaled = scaler.fit_transform(df_features[feature_columns].values)
                
                return data_scaled

        except Exception as e:
            self.monitor.logger.error(f"Error preparing features for {model_type}: {e}")
            return None

    def make_prediction(self, features, model, model_type: str) -> float:
        if features is None or len(features) == 0:
            return 0.5

        if not model:
            return 0.5
            
        try:
            if model_type == 'xgboost':
                latest_features = features.iloc[[-1]]
                probs = model.predict(latest_features) # returns prob of class 1
                return float(probs[0])
            
            elif model_type == 'lstm':
                import torch
                if len(features) < self.seq_length: return 0.5
                sequence = features[-self.seq_length:]
                X_tensor = torch.FloatTensor(sequence).unsqueeze(0)
                with torch.no_grad():
                    logits = model(X_tensor)
                    prediction = torch.sigmoid(logits).item()
                return prediction

        except Exception as e:
            self.monitor.logger.error(f"Prediction error for {model_type}: {e}")
            return 0.5
        
        return 0.5

    def save_market_data(self, symbol, new_df):
        """Append new data to local CSV storage for retraining."""
        if new_df is None or new_df.empty:
            return
            
        data_dir = "data/raw"
        if not os.path.exists(data_dir):
            os.makedirs(data_dir)
            
        file_path = f"{data_dir}/{symbol}.csv"
        
        try:
            if os.path.exists(file_path):
                # Load existing
                existing_df = pd.read_csv(file_path, index_col=0, parse_dates=True)
                # Combine
                combined_df = pd.concat([existing_df, new_df])
                # Drop duplicates based on index
                combined_df = combined_df[~combined_df.index.duplicated(keep='last')]
                combined_df.sort_index(inplace=True)
                combined_df.to_csv(file_path)
            else:
                new_df.to_csv(file_path)
        except Exception as e:
            self.monitor.logger.error(f"Error updating CSV for {symbol}: {e}")

    def run_trading_cycle(self):
        self.monitor.logger.info(f"Trading Cycle - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        # Check for new day to reset daily PnL and trading halt
        current_day = datetime.now().date()
        if current_day != self.last_trade_day:
            self.monitor.logger.info(f"New trading day. Resetting daily PnL from {self.daily_pnl:.2f}.")
            self.daily_pnl = 0.0
            self.last_trade_day = current_day
            self.trading_halted = False

        # 1. Fetch Data
        mt5_enabled = self.config.get('brokers', {}).get('mt5', {}).get('enabled', False)
        deriv_enabled = self.config.get('brokers', {}).get('deriv', {}).get('enabled', False)
        
        if deriv_enabled or self.market_type == 'synthetics':
            # Use Deriv for synthetics
            from data_loader import fetch_historical_data as fetch_deriv
            import asyncio
            data_map = {}
            for symbol in self.symbols:
                # Fetch more candles (500) to account for indicator warmup (200+ for SMA_200)
                df = asyncio.run(fetch_deriv(symbol, time_interval="5m", max_candles=500))
                if df is not None:
                    # Save for retraining
                    self.save_market_data(symbol, df)
                    data_map[symbol] = df
        elif mt5_enabled:
            data_map = fetch_data_mt5(self.symbols, n_candles=100)
        else:
            end_date = datetime.now()
            start_date = end_date - pd.Timedelta(days=60) 
            data_map = fetch_historical_data(self.symbols, start_date=start_date.strftime('%Y-%m-%d'), end_date=end_date.strftime('%Y-%m-%d'))
        
        if not data_map:
             self.monitor.logger.warning("No data fetched.")
             return

        save_data(data_map)

        for symbol, df in data_map.items():
            if df is None or df.empty:
                self.monitor.logger.warning(f"Insufficient data for {symbol}, skipping.")
                continue
                
            current_price = df['Close'].iloc[-1]
            
            if isinstance(self.executor, PaperTradingExecutor):
                self.executor.set_price(symbol, current_price)
            
            strategy_name = self.config.get('model', {}).get('strategy', 'ai')
            
            prediction_input = None
            if strategy_name == 'ensemble':
                predictions = {}
                # Fetch models for this specific symbol
                symbol_models = self.models.get(symbol, {})
                
                for model_type, model in symbol_models.items():
                    features = self.prepare_features(df.copy(), model_type)
                    # Pass model instance explicitly
                    predictions[model_type] = self.make_prediction(features, model, model_type)
                
                log_preds = {k: f"{v:.2%}" for k,v in predictions.items()}
                self.monitor.logger.info(f"Ensemble Predictions for {symbol}: {log_preds}")
                prediction_input = predictions
            
            else: # single 'ai' strategy
                model_type = self.config.get('model', {}).get('type', 'xgboost')
                
                # Fetch model for symbol
                model = self.models.get(symbol, {}).get(model_type)
                features = self.prepare_features(df.copy(), model_type)
                prediction = self.make_prediction(features, model, model_type)
                
                self.monitor.logger.info(f"Model Prediction for {symbol}: {prediction:.2%} ({'UP' if prediction > 0.5 else 'DOWN'})")
                prediction_input = prediction

            if prediction_input is not None:
                # For ensemble, calculate average probability for dashboard display
                if isinstance(prediction_input, dict):
                    avg_prob = sum(prediction_input.values()) / len(prediction_input)
                    signal = "UP" if avg_prob > 0.5 else "DOWN"
                    self.last_prediction[symbol] = {
                        "prob": avg_prob,
                        "signal": signal,
                        "timestamp": datetime.now().isoformat(),
                        "ensemble": prediction_input  # Keep individual predictions
                    }
                else:
                    signal = "UP" if prediction_input > 0.5 else "DOWN"
                    self.last_prediction[symbol] = {
                        "prob": prediction_input,
                        "signal": signal,
                        "timestamp": datetime.now().isoformat()
                    }
                self.execute_strategy(symbol, prediction_input, current_price)


        # 5. Save state for dashboard
        self.save_state()
        
        # 6. Log Cycle Performance
        # ... (logging logic remains the same)

    def execute_strategy(self, symbol, prediction_input, current_price):
        position_info = self.positions.get(symbol)
        action = self.strategy.get_decision(prediction_input, position_info)

        # Prevent new trades if daily loss limit is hit
        if action in [TradeAction.GO_LONG, TradeAction.GO_SHORT]:
            if not self.risk_manager.check_daily_loss(self.daily_pnl):
                self.monitor.logger.warning(f"Daily loss limit reached. Skipping trade for {symbol}.")
                return

        # ========== EXECUTE TRADE ACTION ==========
        try:
            if action == TradeAction.GO_LONG:
                self.monitor.logger.info(f"GO LONG Signal for {symbol} at {current_price}")
                
                # Calculate size
                account = self.executor.get_account()
                equity = account.get('total_equity', self.config['bot']['initial_capital'])
                try:
                    qty = self.risk_manager.calculate_position_size(equity, current_price)
                except Exception as e:
                     self.monitor.logger.error(f"Error calculating size: {e}")
                     qty = 0.01

                if qty > 0:
                    order = self.executor.submit_order(symbol, OrderSide.BUY, qty, order_type="market")
                    if order and order.status == OrderStatus.FILLED:
                        self.positions[symbol] = {'qty': qty, 'side': 'long'}
                        self.entry_prices[symbol] = current_price
                        
                        trade_record = TradeRecord(
                            timestamp=datetime.now().isoformat(),
                            symbol=symbol,
                            side='BUY',
                            quantity=qty,
                            price=current_price,
                            order_id=order.id,
                            notes="AI_ENTRY"
                        )
                        self.monitor.log_trade(trade_record)

            elif action == TradeAction.GO_SHORT:
                self.monitor.logger.info(f"GO SHORT Signal for {symbol} at {current_price}")
                
                # Calculate size
                account = self.executor.get_account()
                equity = account.get('total_equity', self.config['bot']['initial_capital'])
                try:
                    qty = self.risk_manager.calculate_position_size(equity, current_price)
                except Exception as e:
                     self.monitor.logger.error(f"Error calculating size: {e}")
                     qty = 0.01

                if qty > 0:
                    order = self.executor.submit_order(symbol, OrderSide.SELL, qty, order_type="market")
                    if order and order.status == OrderStatus.FILLED:
                        self.positions[symbol] = {'qty': qty, 'side': 'short'}
                        self.entry_prices[symbol] = current_price
                        
                        trade_record = TradeRecord(
                            timestamp=datetime.now().isoformat(),
                            symbol=symbol,
                            side='SELL',
                            quantity=qty,
                            price=current_price,
                            order_id=order.id,
                            notes="AI_ENTRY"
                        )
                        self.monitor.log_trade(trade_record)

            elif action == TradeAction.CLOSE_POSITION:
                if position_info:
                    self.monitor.logger.info(f"Closing Position for {symbol}")
                    
                    # Close position manually by submitting opposite order
                    qty = position_info['qty']
                    close_side = OrderSide.SELL if position_info['side'] == 'long' else OrderSide.BUY
                    order = self.executor.submit_order(symbol, close_side, qty, order_type="market")
                    
                    if order and order.status == OrderStatus.FILLED:
                        # Calculate PnL
                        entry = self.entry_prices.get(symbol, current_price)
                        if position_info['side'] == 'long':
                            bg_pnl = (current_price - entry) * qty
                        else:
                            bg_pnl = (entry - current_price) * qty
                        
                        self.daily_pnl += bg_pnl
                        
                        trade_record = TradeRecord(
                            timestamp=datetime.now().isoformat(),
                            symbol=symbol,
                            side='CLOSE',
                            quantity=qty,
                            price=current_price,
                            order_id=order.id,
                            pnl=bg_pnl,
                            notes="PnL: {:.2f}".format(bg_pnl)
                        )
                        self.monitor.log_trade(trade_record)
                        
                        # Record result for adaptive retraining
                        self.retrainer.record_result(symbol, bg_pnl)
                        
                        # Reset state
                        self.positions[symbol] = None
                        self.entry_prices[symbol] = 0

        except Exception as e:
            self.monitor.logger.error(f"Order Execution Failed: {e}")

    def save_state(self):
        try:
            state_dir = 'state'
            if not os.path.exists(state_dir):
                os.makedirs(state_dir)
            
            account = self.executor.get_account()
            
            pos_list = []
            for sym, pos in self.positions.items():
                if pos:
                    pos_list.append({
                        "symbol": sym,
                        "qty": pos['qty'],
                        "side": pos['side'],
                        "entry_price": self.entry_prices.get(sym, 0),
                        "unrealized_pl": (account.get(sym, {}).get('price', 0) - self.entry_prices.get(sym, 0)) * pos['qty'] if self.entry_prices.get(sym) else 0
                    })

            state = {
                "timestamp": datetime.now().isoformat(),
                "market_type": self.market_type,
                "symbols": self.symbols,
                "account": {
                    "cash": account.get('cash', 0),
                    "equity": account.get('total_equity', 0),
                    "return_pct": account.get('return_pct', 0),
                    "buying_power": account.get('buying_power', 0),
                    "daily_pnl": self.daily_pnl
                },
                "positions": pos_list,
                "trade_history": self.monitor.journal.trades[-50:], 
                "predictions": self.last_prediction,
                "latest_logs": [] 
            }
            
            with open(f'{state_dir}/bot_status.json', 'w') as f:
                json.dump(state, f, indent=2)
        except Exception as e:
            self.monitor.logger.error(f"Error saving state: {e}")

    def start(self):
        self.monitor.logger.info(f"Starting trading bot (interval: {self.trading_interval}s)")
        try:
            while True:
                self.run_trading_cycle()
                self.monitor.logger.info(f"Sleeping {self.trading_interval}s until next cycle...")
                time.sleep(self.trading_interval)
        except KeyboardInterrupt:
            self.monitor.logger.info("Bot stopped by user")
            # Final Report
            print(self.monitor.get_status())

if __name__ == "__main__":
    if not os.path.exists('config.json'):
        print("Config file not found.")
        sys.exit(1)
        
    with open('config.json', 'r') as f:
        config = json.load(f)
        
    bot = TradingBot(config)
    bot.start()
