import logging
import json
import time
import os
import sys
from datetime import datetime
import pandas as pd
import numpy as np

try:
    import yfinance as yf
except ImportError:
    yf = None

# Corrected Imports
# from config import Config  <-- REMOVED
from strategies.risk_manager import RiskManager
from strategies.order_executor import OrderExecutor, OrderSide, OrderStatus, PaperTradingExecutor
from utils.retrainer import RetrainingManager

# Suppress Warnings
from strategy_engine import AIStrategy, EnsembleStrategy, TradeAction
from utils.data_loader import fetch_historical_data, save_data, fetch_data_mt5
from utils.monitoring import BotMonitor, TradeRecord
from models.lstm_model import TradingLSTM
from ai_model import ForexModel

from feature_engine import FeatureEngine

# Setup basic logging first (monitor will take over)
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class TradingBot:
    def __init__(self, config: dict):
        self.config = config
        
        # Initialize Monitor first to capture startup events
        alert_config = config.get('alerts', {})
        self.monitor = BotMonitor(
            log_dir="logs",
            alert_config=alert_config
        )
        
        self.monitor.logger.info("Initializing Trading Bot...")
        
        # Market settings
        self.market_type = config.get('bot', {}).get('market_type', 'forex')
        self.symbols = config.get('markets', {}).get(self.market_type, {}).get('symbols', [])
        
        # Components
        from strategies.risk_manager import RiskParameters
        risk_config = config.get('risk', {})
        risk_params = RiskParameters(
            max_daily_loss_pct=risk_config.get('max_daily_loss_pct', 0.02),
            stop_loss_pct=risk_config.get('stop_loss_pct', 0.02),
            take_profit_pct=risk_config.get('take_profit_pct', 0.04),
            max_open_positions=risk_config.get('max_open_positions', 3),
            min_confidence=risk_config.get('min_confidence', 0.55)
        )
        self.risk_manager = RiskManager(risk_params)
        
        # Order Executor
        if config.get('bot', {}).get('paper_trading', True):
            from strategies.order_executor import PaperTradingExecutor # Import here to avoid circular dependency if OrderExecutor is also in this file
            self.executor = PaperTradingExecutor(initial_capital=config.get('bot', {}).get('initial_capital', 10000))
        elif config.get('brokers', {}).get('deriv', {}).get('enabled'):
            from strategies.deriv_executor import DerivExecutorSync
            deriv_cfg = config.get('brokers', {}).get('deriv', {})
            self.executor = DerivExecutorSync(api_token=deriv_cfg['api_token'], server=deriv_cfg.get('server', 'demo'))
            self.monitor.logger.info("Using Deriv Executor")
        else:
            from strategies.order_executor import MT5Executor
            mt5_cfg = config.get('brokers', {}).get('mt5', {})
            self.executor = MT5Executor(login=int(mt5_cfg['login']), password=mt5_cfg['password'], server=mt5_cfg['server']) 
        
        # Model and Preprocessor Setup for Ensemble

        
        # Model and Preprocessor Setup for Ensemble
        # Note: LSTM input_size must match the number of features generated by FeatureEngine (currently 57)
        self.preprocessors = {
            'lstm': FeatureEngine(),
            'xgboost': FeatureEngine()
        }
        
        # Load models for EACH symbol
        self.models = {}
        for symbol in self.symbols:
            self.monitor.logger.info(f"Loading models for {symbol}...")
            self.models[symbol] = {
                'lstm': self._load_model('lstm', symbol),
                'xgboost': self._load_model('xgboost', symbol)
            }
            
        self.seq_length = config.get('bot', {}).get('seq_length', 30)
        self.trading_interval = config.get('bot', {}).get('trading_interval_seconds', 60)
        
        # Strategy
        strategy_name = config.get('model', {}).get('strategy', 'ai')
        if strategy_name == 'ensemble':
            self.strategy = EnsembleStrategy(config)
            self.monitor.logger.info("Using Ensemble Strategy (weighted average)")
        elif strategy_name == 'any_strong_signal':
            from strategy_engine import AnyStrongSignalStrategy
            self.strategy = AnyStrongSignalStrategy(config)
            self.monitor.logger.info("Using Any Strong Signal Strategy (maximum flexibility)")
        else:
            self.strategy = AIStrategy(config)
            self.monitor.logger.info("Using AI Strategy")


        # State
        self.positions = {symbol: None for symbol in self.symbols}
        self.entry_prices = {symbol: None for symbol in self.symbols}
        self.last_prediction = {}
        self.daily_pnl = 0.0
        self.last_trade_day = datetime.now().date()
        self.trading_halted = False
        
        # Initialize Retrainer
        self.retrainer = RetrainingManager(accuracy_threshold=0.55, min_trades=20)
        
        # WebSocket Client for Real-Time Price Streaming
        self.websocket_client = None
        ws_config = config.get('websocket', {})
        if ws_config.get('enabled', False):
            from websocket_client import DerivWebSocketClient
            deriv_api_token = config.get('brokers', {}).get('deriv', {}).get('api_token')
            self.websocket_client = DerivWebSocketClient(self.symbols, api_token=deriv_api_token)
            self.websocket_client.connect()
            self.monitor.logger.info("âœ… WebSocket price streaming enabled")
        else:
            self.monitor.logger.info("WebSocket disabled - using periodic HTTP polling only")
        
        self.monitor.logger.info(f"Bot initialized for {self.symbols} ({'Paper' if self.executor.paper_trading else 'LIVE'} trading)")

        # Load previous state
        self.load_state()
        # Reconcile with broker state
        self.reconcile_state()

    def load_state(self):
        """Load bot state from a file to resume operations."""
        state_file = 'state/bot_status.json'
        if not os.path.exists(state_file):
            self.monitor.logger.info("No previous state file found. Starting fresh.")
            return

        try:
            with open(state_file, 'r') as f:
                state = json.load(f)
            
            # Restore positions
            if 'positions' in state and state['positions']:
                self.monitor.logger.info("Restoring positions from state file...")
                for pos in state['positions']:
                    symbol = pos.get('symbol')
                    if symbol in self.symbols:
                        self.positions[symbol] = {
                            'qty': pos.get('qty'),
                            'side': pos.get('side')
                        }
                        self.entry_prices[symbol] = pos.get('entry_price')
                        self.monitor.logger.info(f"  - Restored: {pos['side']} {pos['qty']} {symbol} @ {pos['entry_price']}")
            
            # Restore daily PnL if it's from the same day
            if 'timestamp' in state and 'account' in state:
                last_saved_time = datetime.fromisoformat(state['timestamp'])
                if last_saved_time.date() == datetime.now().date():
                    self.daily_pnl = state['account'].get('daily_pnl', 0.0)
                    self.monitor.logger.info(f"Restored daily PnL of {self.daily_pnl:.2f} from today.")

        except Exception as e:
            self.monitor.logger.error(f"Error loading state: {e}")

    def reconcile_state(self):
        """Reconcile bot's state with the broker's actual positions."""
        self.monitor.logger.info("Reconciling state with broker...")
        try:
            live_positions = self.executor.get_open_positions()
            
            if not live_positions:
                self.monitor.logger.info("No open positions found at broker.")
                # If local state has positions, they might be closed/stale. Clear them.
                if any(self.positions.values()):
                    self.monitor.logger.warning("Local state had positions not found at broker. Clearing local state.")
                    self.positions = {symbol: None for symbol in self.symbols}
                    self.entry_prices = {symbol: None for symbol in self.symbols}
                return

            # Create a set of symbols that have live positions
            live_symbols = {pos['symbol'] for pos in live_positions}

            # Sync live positions with bot's state
            for pos in live_positions:
                symbol = pos['symbol']
                if symbol in self.symbols:
                    self.positions[symbol] = {
                        'qty': pos['qty'],
                        'side': pos['side']
                    }
                    self.entry_prices[symbol] = pos['entry_price']
                    self.monitor.logger.info(f"  - Synced from broker: {pos['side']} {pos['qty']} {symbol} @ {pos['entry_price']}")

            # Clear any local positions that are no longer open on the broker
            for symbol in self.symbols:
                if symbol not in live_symbols and self.positions.get(symbol) is not None:
                    self.monitor.logger.warning(f"  - Clearing stale local position for {symbol}.")
                    self.positions[symbol] = None
                    self.entry_prices[symbol] = None
                    
        except Exception as e:
            self.monitor.logger.error(f"Failed to reconcile state with broker: {e}")

    def _load_model(self, model_type: str, symbol: str):
        model_config = self.config.get('model', {})
        
        if model_type == 'xgboost':
            xg_params = model_config.get('xgboost', {})
            # Dynamic path: models/{symbol}_xgboost.json
            actual_path = f"models/{symbol}_xgboost.json"
            
            # Exclude model_path from xg_params
            training_params = {k: v for k, v in xg_params.items() if k != 'model_path'}
            
            model = ForexModel(model_path=actual_path, **training_params)
            if os.path.exists(actual_path):
                model.load_model()
                self.monitor.logger.info(f"[{symbol}] XGBoost Model loaded from {actual_path}")
            else:
                self.monitor.logger.warning(f"[{symbol}] XGBoost model not found at {actual_path}. Using untrained model/fallback.")
            return model

        elif model_type == 'lstm':
            lstm_params = model_config.get('lstm', {})
            # Dynamic path: models/{symbol}_lstm.pth
            model_path = f"models/{symbol}_lstm.pth"
            
            # Input size is 57 (from FeatureEngine with new indicators)
            model = TradingLSTM(input_size=57, hidden_size=lstm_params.get('hidden_size', 64), num_layers=lstm_params.get('num_layers', 2))
            if os.path.exists(model_path):
                import torch
                try:
                    # Note: Loading weights will fail if the model was trained with a different input_size
                    model.load_state_dict(torch.load(model_path))
                    model.eval()
                    self.monitor.logger.info(f"[{symbol}] LSTM Model loaded from {model_path}")
                except Exception as e:
                    self.monitor.logger.error(f"[{symbol}] Failed to load LSTM weights. Using untrained. Error: {e}")
            else:
                self.monitor.logger.warning(f"[{symbol}] LSTM model not found at {model_path}. Using untrained model.")
            return model
        
        return None

    def prepare_features(self, df: pd.DataFrame, model_type: str):
        preprocessor = self.preprocessors.get(model_type)
        if not preprocessor:
            return None

        try:
            if model_type == 'xgboost':
                df_features = preprocessor.generate_features(df)
                ignore_cols = ['Target', 'Future_Return', 'Date', 'index', 'Open', 'High', 'Low', 'Close', 'Volume']
                feature_cols = [c for c in df_features.columns if c not in ignore_cols]
                return df_features[feature_cols] if not df_features.empty else None
            
            elif model_type == 'lstm':
                df_features = preprocessor.generate_features(df)
                
                # Normalize numeric columns (MUST use same scaler as training!)
                feature_columns = [col for col in df_features.columns if df_features[col].dtype in ['float64', 'int64', 'float32', 'int32']]
                feature_columns = [col for col in feature_columns if col not in ['Date', 'Datetime']]
                
                # Load the scaler saved during training
                scaler_path = f"models/{self.symbols[0].replace(' ', '_')}_lstm_scaler.pkl"
                
                if os.path.exists(scaler_path):
                    import joblib
                    scaler = joblib.load(scaler_path)
                    data_scaled = scaler.transform(df_features[feature_columns].values)
                    self.monitor.logger.debug(f"LSTM: Using saved scaler from {scaler_path}")
                else:
                    # Fallback: Create new scaler (but log warning)
                    self.monitor.logger.warning(f"LSTM Scaler not found at {scaler_path}. Using fit_transform (predictions may be unreliable!)")
                    from sklearn.preprocessing import StandardScaler
                    scaler = StandardScaler()
                    data_scaled = scaler.fit_transform(df_features[feature_columns].values)
                
                return data_scaled

        except Exception as e:
            self.monitor.logger.error(f"Error preparing features for {model_type}: {e}")
            return None

    def make_prediction(self, features, model, model_type: str) -> float:
        if features is None or len(features) == 0:
            self.monitor.logger.warning(f"{model_type}: No features provided")
            return None

        if not model:
            self.monitor.logger.warning(f"{model_type}: Model not loaded")
            return None
            
        try:
            if model_type == 'xgboost':
                latest_features = features.iloc[[-1]]
                probs = model.predict(latest_features) # returns prob of class 1
                return float(probs[0])
            
            elif model_type == 'lstm':
                import torch
                if len(features) < self.seq_length:
                    self.monitor.logger.warning(f"LSTM: Insufficient data ({len(features)} < {self.seq_length} required)")
                    return None
                    
                sequence = features[-self.seq_length:]
                X_tensor = torch.FloatTensor(sequence).unsqueeze(0)
                with torch.no_grad():
                    logits = model(X_tensor)
                    prediction = torch.sigmoid(logits).item()
                return prediction

        except Exception as e:
            self.monitor.logger.critical(f"ðŸ”´ MODEL FAILURE ({model_type}): {e}")
            import traceback
            self.monitor.logger.error(traceback.format_exc())
            return None
        
        return None

    def save_market_data(self, symbol, new_df):
        """Append new data to local CSV storage for retraining."""
        if new_df is None or new_df.empty:
            return
            
        data_dir = "data/raw"
        if not os.path.exists(data_dir):
            os.makedirs(data_dir)
            
        file_path = f"{data_dir}/{symbol}.csv"
        
        try:
            if os.path.exists(file_path):
                # Load existing
                existing_df = pd.read_csv(file_path, index_col=0, parse_dates=True)
                # Combine
                combined_df = pd.concat([existing_df, new_df])
                # Drop duplicates based on index
                combined_df = combined_df[~combined_df.index.duplicated(keep='last')]
                combined_df.sort_index(inplace=True)
                combined_df.to_csv(file_path)
            else:
                new_df.to_csv(file_path)
        except Exception as e:
            self.monitor.logger.error(f"Error updating CSV for {symbol}: {e}")

    def run_trading_cycle(self):
        self.monitor.logger.info(f"Trading Cycle - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        # Check for new day to reset daily PnL and trading halt
        current_day = datetime.now().date()
        if current_day != self.last_trade_day:
            self.monitor.logger.info(f"New trading day. Resetting daily PnL from {self.daily_pnl:.2f}.")
            self.daily_pnl = 0.0
            self.last_trade_day = current_day
            self.trading_halted = False

        # Hot Reload Models if Retraining occurred
        if hasattr(self, 'retrainer'):
            symbols_to_reload = list(self.retrainer.reload_needed)
            for symbol in symbols_to_reload:
                try:
                    self.monitor.logger.info(f"[{symbol}] Reloading models following retraining...")
                    if symbol not in self.models:
                        self.models[symbol] = {}
                    
                    # Reload XGBoost
                    self.models[symbol]['xgboost'] = self._load_model('xgboost', symbol)
                    
                    # Reload LSTM
                    self.models[symbol]['lstm'] = self._load_model('lstm', symbol)
                    
                    self.retrainer.reload_needed.remove(symbol)
                    self.monitor.logger.info(f"[{symbol}] Models reloaded successfully. Using updated AI.")
                except Exception as e:
                    self.monitor.logger.error(f"[{symbol}] Failed to reload models: {e}")

        # 1. Fetch Data
        mt5_enabled = self.config.get('brokers', {}).get('mt5', {}).get('enabled', False)
        deriv_enabled = self.config.get('brokers', {}).get('deriv', {}).get('enabled', False)
        
        
        h1_data_map = {}
        if mt5_enabled:
            # Use MT5 for fast data fetching (works for Synthetics too)
            # Need to map long names back to short names if existing code expects short names?
            # Actually fetch_data_mt5 takes list of symbols. 
            # Current symbols are ["Volatility 75 Index", ...].
            data_map = fetch_data_mt5(self.symbols, n_candles=500, timeframe="M5")
            
            # Phase 2: Fetch 1H Data for Trend Filter
            try:
                h1_data_map = fetch_data_mt5(self.symbols, n_candles=50, timeframe="H1")
                if h1_data_map:
                    self.monitor.logger.info(f"Fetched 1H Trend Data for {len(h1_data_map)} symbols.")
            except Exception as e:
                self.monitor.logger.error(f"Failed to fetch H1 data: {e}")
                
        elif deriv_enabled or self.market_type == 'synthetics':
            # Fallback to Deriv API
            from data_loader import fetch_historical_data as fetch_deriv
            import asyncio
            data_map = {}
            for symbol in self.symbols:
                df = asyncio.run(fetch_deriv(symbol, time_interval="5m", max_candles=500))
                if df is not None:
                    self.save_market_data(symbol, df)
                    data_map[symbol] = df
        else:
            end_date = datetime.now()
            start_date = end_date - pd.Timedelta(days=60) 
            data_map = fetch_historical_data(self.symbols, start_date=start_date.strftime('%Y-%m-%d'), end_date=end_date.strftime('%Y-%m-%d'))
        
        if not data_map:
             self.monitor.logger.warning("No data fetched.")
             return

        save_data(data_map)

        for symbol, df in data_map.items():
            if df is None or df.empty:
                self.monitor.logger.warning(f"Insufficient data for {symbol}, skipping.")
                continue
                
            current_price = df['Close'].iloc[-1]
            
            if isinstance(self.executor, PaperTradingExecutor):
                self.executor.set_price(symbol, current_price)
            
            strategy_name = self.config.get('model', {}).get('strategy', 'ai')
            
            prediction_input = None
            if strategy_name == 'ensemble':
                predictions = {}
                
                # Ensure models are loaded for this symbol
                if symbol not in self.models or not self.models[symbol]:
                    self.models[symbol] = {
                        'xgboost': self._load_model('xgboost', symbol),
                        'lstm': self._load_model('lstm', symbol)
                    }
                
                symbol_models = self.models.get(symbol, {})
                
                for model_type, model in symbol_models.items():
                    if model is None:
                        continue
                    features = self.prepare_features(df.copy(), model_type)
                    # Pass model instance explicitly
                    pred_result = self.make_prediction(features, model, model_type)
                    
                    # Only add valid predictions (skip None)
                    if pred_result is not None:
                        predictions[model_type] = pred_result
                
                # Update ensemble weights based on recent model accuracy
                model_weights = self.retrainer.get_model_weights(symbol)
                self.strategy.set_weights(model_weights)
                
                log_preds = {k: f"{v:.2%}" for k,v in predictions.items()}
                log_weights = {k: f"{v:.1%}" for k,v in model_weights.items()}
                self.monitor.logger.info(f"Ensemble Predictions for {symbol}: {log_preds} (Weights: {log_weights})")
                
                # Guard against empty predictions
                if predictions and len(predictions) > 0:
                    prediction_input = predictions
                else:
                    self.monitor.logger.warning(f"[{symbol}] No valid model predictions available, skipping.")
                    continue
            
            else: # single 'ai' strategy
                model_type = self.config.get('model', {}).get('type', 'xgboost')
                
                # Fetch model for symbol
                model = self.models.get(symbol, {}).get(model_type)
                features = self.prepare_features(df.copy(), model_type)
                prediction = self.make_prediction(features, model, model_type)
                
                self.monitor.logger.info(f"Model Prediction for {symbol}: {prediction:.2%} ({'UP' if prediction > 0.5 else 'DOWN'})")
                
                # Wrap single prediction in dict for strategy compatibility (especially AnyStrongSignalStrategy)
                prediction_input = {model_type: prediction}

            if prediction_input is not None:
                # For ensemble, calculate average probability for dashboard display
                if isinstance(prediction_input, dict):
                    avg_prob = sum(prediction_input.values()) / len(prediction_input)
                    signal = "UP" if avg_prob > 0.5 else "DOWN"
                    self.last_prediction[symbol] = {
                        "prob": avg_prob,
                        "signal": signal,
                        "timestamp": datetime.now().isoformat(),
                        "ensemble": prediction_input  # Keep individual predictions
                    }
                else:
                    signal = "UP" if prediction_input > 0.5 else "DOWN"
                    self.last_prediction[symbol] = {
                        "prob": prediction_input,
                        "signal": signal,
                        "timestamp": datetime.now().isoformat()
                    }
                if self.market_type == 'synthetics' or mt5_enabled:
                    # Calculate 1H Trend Context
                    trend_context = None
                    if symbol in h1_data_map:
                        h1_df = h1_data_map[symbol]
                        if not h1_df.empty and len(h1_df) > 49:
                             # Simple Trend: Price > SMA 50 ?
                             sma_50 = h1_df['Close'].rolling(window=50).mean().iloc[-1]
                             h1_price = h1_df['Close'].iloc[-1]
                             trend_context = 'UP' if h1_price > sma_50 else 'DOWN'
                             # self.monitor.logger.info(f"[{symbol}] H1 Trend: {trend_context}")

                    self.execute_strategy(symbol, prediction_input, current_price, trend_context=trend_context, df=df)
                else:
                    self.execute_strategy(symbol, prediction_input, current_price, df=df)


        # 5. Save state for dashboard
        self.save_state()
        
        # 6. Log Cycle Performance
        # ... (logging logic remains the same)

    def execute_strategy(self, symbol, prediction_input, current_price, trend_context=None, df=None):
        position_info = self.positions.get(symbol)
        action = None # Initialize action

        # ========== CHECK EXITS FIRST (SL, TP, TRAILING) ==========
        if position_info:
            # 1. Check HARD Stop-Loss and Take-Profit
            sl_price = position_info.get('sl_price')
            tp_price = position_info.get('tp_price')

            if position_info['side'] == 'long':
                if sl_price and current_price <= sl_price:
                    self.monitor.logger.warning(f"[{symbol}] STOP-LOSS HIT @ {current_price:.4f} (SL: {sl_price:.4f})")
                    action = TradeAction.CLOSE_POSITION
                elif tp_price and current_price >= tp_price:
                    self.monitor.logger.info(f"[{symbol}] TAKE-PROFIT HIT @ {current_price:.4f} (TP: {tp_price:.4f})")
                    action = TradeAction.CLOSE_POSITION
            elif position_info['side'] == 'short':
                if sl_price and current_price >= sl_price:
                    self.monitor.logger.warning(f"[{symbol}] STOP-LOSS HIT @ {current_price:.4f} (SL: {sl_price:.4f})")
                    action = TradeAction.CLOSE_POSITION
                elif tp_price and current_price <= tp_price:
                    self.monitor.logger.info(f"[{symbol}] TAKE-PROFIT HIT @ {current_price:.4f} (TP: {tp_price:.4f})")
                    action = TradeAction.CLOSE_POSITION
            
            # 2. Check TRAILING STOP (only if no hard SL/TP was hit)
            if action is None:
                trailing_result = self.risk_manager.update_trailing_stop(symbol, current_price)
                if trailing_result['triggered']:
                    self.monitor.logger.warning(f"[{symbol}] TRAILING STOP TRIGGERED - Forcing position close")
                    action = TradeAction.CLOSE_POSITION
        
        # ========== GET AI-DRIVEN ACTION (if no exit was triggered) ==========
        if action is None:
            # Pass trend_context to strategy
            if hasattr(self.strategy, 'get_decision') and 'trend_context' in self.strategy.get_decision.__code__.co_varnames:
                 action = self.strategy.get_decision(prediction_input, position_info, symbol=symbol, trend_context=trend_context)
            else:
                 action = self.strategy.get_decision(prediction_input, position_info, symbol=symbol)

        # Prevent new trades if daily loss limit is hit
        if action in [TradeAction.GO_LONG, TradeAction.GO_SHORT]:
            if not self.risk_manager.check_daily_loss(self.daily_pnl):
                self.monitor.logger.warning(f"Daily loss limit reached. Skipping trade for {symbol}.")
                return

        # ========== EXECUTE TRADE ACTION ==========
        try:
            if action == TradeAction.GO_LONG:
                self.monitor.logger.info(f"GO LONG Signal for {symbol} at {current_price}")
                
                # Calculate size and exits
                account = self.executor.get_account()
                equity = account.get('total_equity', self.config['bot']['initial_capital'])
                qty = 0
                sl_price, tp_price = None, None # Init

                try:
                    # Use Forex specific ATR calculation
                    if self.market_type in ['forex', 'synthetics'] and hasattr(self.risk_manager, 'calculate_forex_position_size') and df is not None:
                        atr = df['ATR'].iloc[-1]
                        qty = self.risk_manager.calculate_forex_position_size(equity, symbol, atr=atr)
                        exit_prices = self.risk_manager.get_forex_exit_prices(current_price, symbol, 'long', atr=atr)
                        sl_price = exit_prices['stop_loss']
                        tp_price = exit_prices['take_profit']
                    else: # Non-Forex: Stocks, Crypto, etc.
                        # Calculate exit prices first
                        exit_prices = self.risk_manager.get_stock_exit_prices(current_price, 'long')
                        sl_price = exit_prices['stop_loss']
                        tp_price = exit_prices['take_profit']
                        # Calculate position size based on risk and stop loss
                        qty = self.risk_manager.calculate_position_size(equity, current_price, sl_price, 'long')

                except Exception as e:
                     self.monitor.logger.error(f"Error calculating size/exits: {e}")
                     qty = 0 # Safety check

                if qty > 0:
                    order = self.executor.submit_order(symbol, OrderSide.BUY, qty, order_type="market")
                    if order and order.status == OrderStatus.FILLED:
                        # Update position state with exit prices
                        self.positions[symbol] = {
                            'qty': qty, 
                            'side': 'long',
                            'sl_price': sl_price,
                            'tp_price': tp_price
                        }
                        self.entry_prices[symbol] = current_price
                        # Register with risk manager for trailing stop
                        self.risk_manager.register_position(symbol, current_price, qty, 'long', stop_loss_price=sl_price)
                        
                        trade_record = TradeRecord(
                            timestamp=datetime.now().isoformat(),
                            symbol=symbol,
                            side='BUY',
                            quantity=qty,
                            price=current_price,
                            order_id=order.id,
                            notes=f"AI_ENTRY | SL: {sl_price:.4f}, TP: {tp_price:.4f}" if sl_price else "AI_ENTRY"
                        )
                        self.monitor.log_trade(trade_record)

            elif action == TradeAction.GO_SHORT:
                self.monitor.logger.info(f"GO SHORT Signal for {symbol} at {current_price}")
                
                # Calculate size and exits
                account = self.executor.get_account()
                equity = account.get('total_equity', self.config['bot']['initial_capital'])
                qty = 0
                sl_price, tp_price = None, None # Init

                try:
                     # Use Forex specific ATR calculation
                    if self.market_type in ['forex', 'synthetics'] and hasattr(self.risk_manager, 'calculate_forex_position_size') and df is not None:
                        atr = df['ATR'].iloc[-1]
                        qty = self.risk_manager.calculate_forex_position_size(equity, symbol, atr=atr)
                        exit_prices = self.risk_manager.get_forex_exit_prices(current_price, symbol, 'short', atr=atr)
                        sl_price = exit_prices['stop_loss']
                        tp_price = exit_prices['take_profit']
                    else: # Non-Forex: Stocks, Crypto, etc.
                        # Calculate exit prices first
                        exit_prices = self.risk_manager.get_stock_exit_prices(current_price, 'short')
                        sl_price = exit_prices['stop_loss']
                        tp_price = exit_prices['take_profit']
                        # Calculate position size based on risk and stop loss
                        qty = self.risk_manager.calculate_position_size(equity, current_price, sl_price, 'short')

                except Exception as e:
                     self.monitor.logger.error(f"Error calculating size/exits: {e}")
                     qty = 0

                if qty > 0:
                    order = self.executor.submit_order(symbol, OrderSide.SELL, qty, order_type="market")
                    if order and order.status == OrderStatus.FILLED:
                        self.positions[symbol] = {
                            'qty': qty, 
                            'side': 'short',
                            'sl_price': sl_price,
                            'tp_price': tp_price
                        }
                        self.entry_prices[symbol] = current_price
                        self.risk_manager.register_position(symbol, current_price, qty, 'short', stop_loss_price=sl_price)
                        
                        trade_record = TradeRecord(
                            timestamp=datetime.now().isoformat(),
                            symbol=symbol,
                            side='SELL',
                            quantity=qty,
                            price=current_price,
                            order_id=order.id,
                            notes=f"AI_ENTRY | SL: {sl_price:.4f}, TP: {tp_price:.4f}" if sl_price else "AI_ENTRY"
                        )
                        self.monitor.log_trade(trade_record)

            elif action == TradeAction.CLOSE_POSITION:
                if position_info:
                    self.monitor.logger.info(f"Closing Position for {symbol}")
                    
                    # Close position manually by submitting opposite order
                    qty = position_info['qty']
                    close_side = OrderSide.SELL if position_info['side'] == 'long' else OrderSide.BUY
                    order = self.executor.submit_order(symbol, close_side, qty, order_type="market")
                    
                    if order and order.status == OrderStatus.FILLED:
                        # Calculate PnL
                        entry = self.entry_prices.get(symbol, current_price)
                        if position_info['side'] == 'long':
                            bg_pnl = (current_price - entry) * qty
                        else:
                            bg_pnl = (entry - current_price) * qty
                        
                        self.daily_pnl += bg_pnl
                        
                        trade_record = TradeRecord(
                            timestamp=datetime.now().isoformat(),
                            symbol=symbol,
                            side='CLOSE',
                            quantity=qty,
                            price=current_price,
                            order_id=order.id,
                            pnl=bg_pnl,
                            notes="PnL: {:.2f}".format(bg_pnl)
                        )
                        self.monitor.log_trade(trade_record)
                        
                        # Record result for adaptive retraining
                        self.retrainer.record_result(symbol, bg_pnl)
                        
                        # Reset state
                        self.positions[symbol] = None
                        self.entry_prices[symbol] = 0

        except Exception as e:
            self.monitor.logger.error(f"Order Execution Failed: {e}")

    def save_state(self):
        try:
            state_dir = 'state'
            if not os.path.exists(state_dir):
                os.makedirs(state_dir)
            
            account = self.executor.get_account()
            
            pos_list = []
            for sym, pos in self.positions.items():
                if pos:
                    pos_list.append({
                        "symbol": sym,
                        "qty": pos['qty'],
                        "side": pos['side'],
                        "entry_price": self.entry_prices.get(sym, 0),
                        "unrealized_pl": (account.get(sym, {}).get('price', 0) - self.entry_prices.get(sym, 0)) * pos['qty'] if self.entry_prices.get(sym) else 0
                    })

            state = {
                "timestamp": datetime.now().isoformat(),
                "market_type": self.market_type,
                "symbols": self.symbols,
                "account": {
                    "cash": account.get('cash', 0),
                    "equity": account.get('total_equity', 0),
                    "return_pct": account.get('return_pct', 0),
                    "buying_power": account.get('buying_power', 0),
                    "daily_pnl": self.daily_pnl
                },
                "positions": pos_list,
                "trade_history": self.monitor.get_recent_trades(50), 
                "predictions": self.last_prediction,
                "latest_logs": [] 
            }
            
            with open(f'{state_dir}/bot_status.json', 'w') as f:
                json.dump(state, f, indent=2)
        except Exception as e:
            self.monitor.logger.error(f"Error saving state: {e}")


    def check_exits(self):
        """
        Lightweight check running every second.
        Safely monitors Stop-Loss and Take-Profit using real-time WebSocket prices.
        And GLOBAL DRAWDOWN (Equity Guard).
        """
        try:
            # Only check if we have active positions
            active_symbols = [s for s, pos in self.positions.items() if pos is not None]
            if not active_symbols:
                return

            # Use WebSocket for real-time prices if available, else skip (will be checked in main cycle)
            if not self.websocket_client or not self.websocket_client.is_connected():
                return
            
            for symbol in active_symbols:
                try:
                    position_info = self.positions[symbol]
                    
                    # Get real-time price from WebSocket
                    current_price = self.websocket_client.get_latest_price(symbol)
                    if current_price is None:
                        continue  # No price data yet
                    
                    # Check SL/TP thresholds
                    sl_price = position_info.get('sl_price')
                    tp_price = position_info.get('tp_price')
                    position_side = position_info['side']
                    
                    should_close = False
                    exit_reason = ""
                    
                    if position_side == 'long':
                        if sl_price and current_price <= sl_price:
                            should_close = True
                            exit_reason = f"STOP-LOSS HIT @ {current_price:.4f} (SL: {sl_price:.4f})"
                        elif tp_price and current_price >= tp_price:
                            should_close = True
                            exit_reason = f"TAKE-PROFIT HIT @ {current_price:.4f} (TP: {tp_price:.4f})"
                    else:  # short
                        if sl_price and current_price >= sl_price:
                            should_close = True
                            exit_reason = f"STOP-LOSS HIT @ {current_price:.4f} (SL: {sl_price:.4f})"
                        elif tp_price and current_price <= tp_price:
                            should_close = True
                            exit_reason = f"TAKE-PROFIT HIT @ {current_price:.4f} (TP: {tp_price:.4f})"
                    
                    # Also check trailing stop
                    if not should_close:
                        trailing_result = self.risk_manager.update_trailing_stop(symbol, current_price)
                        if trailing_result['triggered']:
                            should_close = True
                            exit_reason = f"TRAILING STOP HIT @ {current_price:.4f} (Stop: {trailing_result['stop_level']:.4f})"
                    
                    # Execute close if triggered
                    if should_close:
                        self.monitor.logger.warning(f"[{symbol}] {exit_reason}")
                        
                        qty = position_info['qty']
                        close_side = OrderSide.SELL if position_side == 'long' else OrderSide.BUY
                        
                        try:
                            order = self.executor.submit_order(symbol, close_side, qty, order_type="market")
                            
                            if order and order.status == OrderStatus.FILLED:
                                # Calculate PnL
                                entry = self.entry_prices.get(symbol, current_price)
                                if position_side == 'long':
                                    pnl = (current_price - entry) * qty
                                else:
                                    pnl = (entry - current_price) * qty
                                
                                self.daily_pnl += pnl
                                
                                trade_record = TradeRecord(
                                    timestamp=datetime.now().isoformat(),
                                    symbol=symbol,
                                    side='CLOSE',
                                    quantity=qty,
                                    price=current_price,
                                    order_id=order.id,
                                    pnl=pnl,
                                    notes=f"WebSocket Exit: {exit_reason}"
                                )
                                self.monitor.log_trade(trade_record)
                                
                                # Record result for retraining
                                self.retrainer.record_result(symbol, pnl)
                                
                                # Clear position
                                self.positions[symbol] = None
                                self.entry_prices[symbol] = 0
                                self.risk_manager.close_position(symbol, current_price)
                                
                        except Exception as e:
                            self.monitor.logger.error(f"Failed to close position for {symbol}: {e}")
                
                except Exception as e:
                    self.monitor.logger.error(f"Error checking exit for {symbol}: {e}")
                    continue

        except Exception as e:
            # Prevent one error from crashing the heartbeat
            if isinstance(e, SystemExit):
                raise e
            self.monitor.logger.error(f"Error in check_exits: {e}") 

    def start(self):
        """
        Main execution loop (Smart Loop).
        - Tick interval: 1 second
        - Analysis interval: 5 minutes (approx)
        """
        self.monitor.logger.info("Bot started in Smart Loop Mode. Ticking every 1s...")
        print(f"Bot started. Press Ctrl+C to stop.")
        
        last_analysis_time = 0
        
        while True:
            try:
                # 1. Check for manual commands
                # Inline command processing logic directly here to ensure it works
                if os.path.exists('command.json'):
                    try:
                        with open('command.json', 'r') as f:
                            cmd_data = json.load(f)
                        
                        cmd = cmd_data.get('command', 'RUN')
                        
                        if cmd == 'STOP':
                            # self.monitor.logger.info("PAUSED by user command. Waiting...")
                            time.sleep(2)
                            continue
                            
                        elif cmd == 'MANUAL_TRADE':
                            # Execute manual trade if parameters provided
                            params = cmd_data.get('params', {})
                            self.monitor.logger.info(f"Executing Manual Trade: {params}")
                            # Reset command to prevent double execution
                            with open('command.json', 'w') as f:
                                json.dump({"command": "RUN", "timestamp": datetime.now().isoformat()}, f)
                            
                            # Execute
                            try:
                                # Quick implementation of manual trade
                                symbol = params.get('symbol')
                                side = params.get('side') # BUY/SELL
                                qty = float(params.get('qty', 0.01))
                                
                                if symbol and side:
                                    order_side = OrderSide.BUY if side.upper() == 'BUY' else OrderSide.SELL
                                    self.executor.submit_order(symbol, order_side, qty, order_type="market")
                                    self.monitor.logger.info(f"Manual {side} order for {symbol} submitted.")
                            except Exception as e:
                                self.monitor.logger.error(f"Manual trade failed: {e}")
                                
                    except Exception as e:
                        pass # self.monitor.logger.error(f"Command error: {e}")

                # 2. Safety / Exit Checks (Every tick)
                self.check_exits()
                
                # 3. Main Analysis (Every 5 minutes or on startup)
                # We use OS time to align with candles (minute 0, 5, 10...)
                now = datetime.now()
                is_candle_close = (now.minute % 5 == 0 and now.second < 5)
                # Startup condition: last_analysis_time == 0
                is_startup = (last_analysis_time == 0)
                is_stale = (time.time() - last_analysis_time > 300)
                
                if is_candle_close or is_startup or is_stale:
                    # Debounce: Ensure we don't run multiple times in the same minute-window
                    # Exception: Startup runs immediately
                    if is_startup or (time.time() - last_analysis_time > 60): 
                        self.monitor.logger.info(f"Triggering Analysis Cycle at {now.strftime('%H:%M:%S')}")
                        self.run_trading_cycle()
                        last_analysis_time = time.time()
                
                # 4. Sleep
                time.sleep(1)
                
            except KeyboardInterrupt:
                self.monitor.logger.info("Bot stopped by user")
                
                # Disconnect WebSocket
                if self.websocket_client:
                    self.websocket_client.disconnect()
                
                # Final Report
                print(self.monitor.get_status())
                break
            except Exception as e:
                self.monitor.logger.error(f"Critical Loop Error: {e}")
                time.sleep(5)


from utils.config_loader import load_config

if __name__ == "__main__":
    if not os.path.exists('config.json'):
        print("Config file not found.")
        sys.exit(1)
        
    config = load_config()
        
    bot = TradingBot(config)
    bot.start()
